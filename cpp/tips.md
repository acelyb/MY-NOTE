# CPP tips

## const 相关

### 函数名后加 const

只有类的成员函数才能在函数名后面加上const，这时成员函数叫做常量成员函数。

常量成员函数在执行期间不能修改成员变量的值（静态成员变量除外），也不能调用同类的非常量成员函数（同样的静态成员函数除外）。

增强健壮性。

常成员函数说明格式：类型说明符  函数名（参数表）const;

这里，const 是函数类型的一个组成部分，因此在实现部分也要带 const 关键字。

const 关键字可以被用于参与对重载函数的区分

通过常对象只能调用它的常成员函数

```cpp
class Sample{
    public:
        int value;
        void GetValue() const;
        void func() {};
        Sample() { value = 0; }
};

void Sample::GetValue() const {
    value = 0;  // 错误，常量成员函数不能修改成员变量的值
    func();     // 错误，常量成员函数不能调用非常量成员函数
}

int main(void) {
    const Sample s;
    s.value = 1;    // 错误，常量对象不能被修改
    s.func();       // 错误，常量对象上面不能执行非常量成员函数，即使这个成员函数为空
    s.GetValue();   // 正确，常量对象上面可以执行常量函数
    return 0;
}
```

注：

1. 非静态成员函数后才能加 const，加到非成员函数或静态成员后面会产生编译错误。
2. 表示成员函数隐含传入的this指针为 const 指针，决定了在该成员函数中，任意修改它所在的类的成员的操作都是不允许的（因为隐含了对this指针的 const 引用），唯一的例外是对于 mutable 修饰的成员。
3. 调用
   * 加了 const 的成员函数可以被非 const 对象和 const 对象调用
   * 不加 const 的成员函数只能被非 const 对象调用

### 常对象

常类型的对象必须进行初始化，而且不能被更新。

* 常引用：被引用的对象不能被更新。
const  类型说明符  &引用名
* 常对象：必须进行初始化,不能被更新。
类名  const  对象名
* 常数组：数组元素不能被更新。
类型说明符  const  数组名[大小]...
* 常指针：指向常量的指针。

## static 相关

### 静态成员函数

类外代码可以使用类名和作用域操作符来调用静态成员函数。静态成员函数只能引用属于该类的静态数据成员或静态成员函数。

```CPP
class Application {
 public:
  static void f();
  static void g();

 private:
  static int global;
};
int Application::global = 0;
void Application::f() { global = 5; }
void Application::g() { cout << global << endl; }

int main() {
  Application::f();
  Application::g();
  system("pause");
  return 0;
}
```

```cpp
class A {
 public:
  static void f(A a);

 private:
  int x;
};
void A::f(A a) {
  //静态成员函数只能引用属于该类的静态数据成员或静态成员函数。
  // cout<<x; //对x的引用是错误的
  cout << a.x;  //正确
}

int main(int argc, char const *argv[]) {
  A a;
  a.f(A());
  system("pause");
  return 0;
}
```

### 静态数据成员

静态数据成员用关键字static声明，该类的所有对象维护该成员的同一个拷贝。必须在类外定义和初始化，用(::)来指明所属的类。

```cpp
class Point {
 public:
  Point(int xx = 0, int yy = 0) {
    X = xx;
    Y = yy;
    countP++;
  }
  Point(Point &p);
  int GetX() { return X; }
  int GetY() { return Y; }
  void GetC() { cout << " Object id=" << countP << endl; }

 private:
  int X, Y;
  //静态数据成员，必须在外部定义和初始化，内部不能直接初始化！
  static int countP;
};
Point::Point(Point &p) {
  X = p.X;
  Y = p.Y;
  countP++;
}
//必须在类外定义和初始化，用(::)来指明所属的类。
int Point::countP = 0;
int main() {
  Point A(4, 5);
  cout << "Point A," << A.GetX() << "," << A.GetY();
  A.GetC();
  Point B(A);
  cout << "Point B," << B.GetX() << "," << B.GetY();
  B.GetC();
  system("pause");
  return 0;
}
```

## 类相关

### 类对象的构造

先构造成员，再构造自身（调用构造函数）

### 派生类构造函数

派生类可能有多个基类，也可能包括多个成员对象，在创建派生类对象时，派生类的构造函数除了要负责本类成员的初始化外，还要调用基类和成员对象的构造函数，并向它们传递参数，以完成基类子对象和成员对象的建立和初始化。

**派生类只能采用构造函数初始化列表的方式向基类或成员对象的构造函数传递参数**，形式如下：

派生类构造函数名(参数表):基类构造函数名(参数表),成员对象名1(参数表),…{
    //……
}

### 构造函数和析构函数调用次序

#### 派生类对象构造

* 先构造基类
* 再构造成员
* 最后构造自身（调用构造函数）

基类构造顺序由派生层次决定：**最远的基类最先构造**

成员构造顺序和定义顺序符合

析构函数的析构顺序与构造相反

#### 基类与派生类对象的关系

基类对象与派生类对象之间存在赋值相容性。包括以下几种情况：

* 把派生类对象赋值给基类对象
* 把派生类对象的地址赋值给基类指针
* 用派生类对象初始化基类对象的引用

反之则不行，即不能把基类对象赋值给派生类对象；不能把基类对象的地址赋值给派生类对象的指针；也不能把基类对象作为派生对象的引用。

### 继承

#### 公有继承

1. 基类中 protected 的成员
   1. 类内部：可以访问
   2. 类的使用者：不能访问
   3. 类的派生类成员：可以访问
2. 派生类不可访问基类的 private 成员
3. 派生类可以访问基类的 protected 成员
4. 派生类可访问基类的 public 成员

| 基类 | public 继承 | 派生类 |
| :---: | :---: | :---: |
| public | ---> | public |
| protected | ---> | protected |
| private | ---> | 不可访问 |

#### 私有继承

派生类也不可访问基类的 private 成员

| 基类 | private 继承 | 派生类 |
| :---: | :---: | :---: |
| public | ---> | private |
| protected | ---> | private |
| private | ---> | 不可访问 |

#### 保护继承

派生方式为 protected 的继承称为保护继承，在这种继承方式下，基类的 public 成员在派生类中会变成 protected 成员，基类的 protected 和 private 成员在派生类中保持原来的访问权限

注意：当采用保护继承的时候，由于 public 成员变为 protected 成员，因此类的使用者不可访问，而派生类可以访问

| 基类 | protected 继承 | 派生类 |
| :---: | :---: | :---: |
| public | ---> | protected |
| protected | ---> | protected |
| private | ---> | 不可访问 |

#### 派生类对于基类成员的访问形式

1. 通过派生类对象直接访问基类成员
2. 在派生类成员函数中直接访问基类成员
3. 通过基类名字限定访问被重载的基类成员名

### 友元

友元函数是在类声明中由关键字friend修饰说明的非成员函数，在它的函数体中能够通过对象名访问 private 和 protected成员作用：增加灵活性，使程序员可以在封装和快速性方面做合理选择。访问对象中的成员必须通过对象名。

若一个类为另一个类的友元，则此类的所有成员都能访问对方类的私有成员。声明语法：将友元类名在另一个类中使用friend修饰说明。

如果声明B类是A类的友元，B类的成员函数就可以访问A类的私有和保护数据，但A类的成员函数却不能访问B类的私有、保护数据。

```cpp
class A {
  friend class B;

 public:
  void Display() { cout << x << endl; }

 private:
  int x;
};
class B {
 public:
  void Set(int i);
  void Display();

 private:
  A a;
};
void B::Set(int i) { a.x = i; }
void B::Display() { a.Display(); }

int main(int argc, char const *argv[]) {
  B b;
  b.Set(10);
  b.Display();

  system("pause");
  return 0;
}
```

友元是C++提供的一种破坏数据封装和数据隐藏的机制。通过将一个模块声明为另一个模块的友元，一个模块能够引用到另一个模块中本是被隐藏的信息。可以使用友元函数和友元类。为了确保数据的完整性，及数据封装与隐藏的原则，建议尽量不使用或少使用友元。

### 调用规则

当同时存在直接基类和间接基类时，每个派生类只负责其直接基类的构造。

### 构造函数和析构函数的构造规则

#### 派生类可以不定义构造函数的情况

* 当具有下述情况之一时，派生类可以不定义构造函数。
* 基类没有定义任何构造函数。
* 基类具有缺省参数的构造函数。
* 基类具有无参构造函数。

#### 派生类必须定义构造函数的情况

* 当基类或成员对象所属类只含有带参数的构造函数时，即使派生类本身没有数据成员要初始化，它也必须定义构造函数，并以构造函数初始化列表的方式向基类和成员对象的构造函数传递参数，以实现基类子对象和成员对象的初始化。

#### 派生类的构造函数只负责直接基类的初始化

C++语言标准有一条规则：如果派生类的基类同时也是另外一个类的派生类，则每个派生类只负责它的直接基类的构造函数调用。

这条规则表明当派生类的直接基类只有带参数的构造函数，但没有默认构造函数时（包括缺省参数和无参构造函数），它必须在构造函数的初始化列表中调用其直接基类的构造函数，并向基类的构造函数传递参数，以实现派生类对象中的基类子对象的初始化。

这条规则有一个例外情况，当派生类存在虚基类时，所有虚基类都由最后的派生类负责初始化。

#### 总结

1. 当有多个基类时，将按照它们在继承方式中的声明次序调用，与它们在构造函数初始化列表中的次序无关。当基类A本身又是另一个类B的派生类时，则先调用基类B的构造函数，再调用基类A的构造函数。
2. 当有多个对象成员时，将按它们在派生类中的声明次序调用，与它们在构造函数初始化列表中的次序无关。
3. 当构造函数初始化列表中的基类和对象成员的构造函数调用完成之后，才执行派生类构造函数体中的程序代码。

```cpp
// 当同时存在直接基类和间接基类时，每个派生类只负责其直接基类的构造。
class A {
  int x;

 public:
  A(int aa) {
    x = aa;
    cout << "Constructing A" << endl;
  }
  ~A() { cout << "Destructing A" << endl; }
};
class B : public A {
 public:
  B(int x) : A(x) { cout << "Constructing B" << endl; }
};
class C : public B {
 public:
  C(int y) : B(y) { cout << "Constructing C" << endl; }
};
int main() {
  C c(1);
  system("pause");
}
```

### 虚拟继承

多继承下的二义性：在多继承方式下，派生类继承了多个基类的成员，当两个不同基类拥有同名成员时，容易产生名字冲突问题。

虚拟继承引入的原因：重复基类，派生类间接继承同一基类使得间接基类（Person）在派生类中有多份拷贝，引发二义性。

#### 虚拟继承 virtual inheritance 的定义

##### 语法

class derived_class : virtual […] base_class

虚基类virtual base class

被虚拟继承的基类在其所有的派生类中，仅出现一次

##### 虚拟继承的构造次序

虚基类的初始化与一般的多重继承的初始化在语法上是一样的，但构造函数的调用顺序不同

若基类由虚基类派生而来，则派生类必须提供对间接基类的构造（即在构造函数初始列表中构造虚基类，无论此虚基类是直接还是间接基类）

调用顺序的规定：

* 先调用虚基类的构造函数，再调用非虚基类的构造函数
* 若同一层次中包含多个虚基类,这些虚基类的构造函数按它们的说明的次序调用
* 若虚基类由非基类派生而来,则仍然先调用基类构造函数,再调用派生类构造函数

##### 虚基类由最终派生类初始化

在没有虚拟继承的情况下，每个派生类的构造函数只负责其直接基类的初始化。但在虚拟继承方式下，虚基类则由最终派生类的构造函数负责初始化。

在虚拟继承方式下，若最终派生类的构造函数没有明确调用虚基类的构造函数，编译器就会尝试调用虚基类不需要参数的构造函数（包括缺省、无参和缺省参数的构造函数），如果没找到就会产生编译错误。

### 多态性

多态性：多态就是在同一个类或继承体系结构的基类与派生类中，用同名函数来实现各种不同的功能

**静态绑定又称静态联编**，是指在编译程序时就根据调用函数提供的信息，把它所对应的具体函数确定下来，即在编译时就把调用函数名与具体函数绑定在一起。

**动态绑定又称动态联编**，是指在编译程序时还不能确定函数调用所对应的具体函数，只有在程序运行过程中才能够确定函数调用所对应的具体函数，即在程序运行时才把调用函数名与具体函数绑定在一起。

编译时多态性：---静态联编(连接)----系统在编译时就决定如何实现某一动作，即对某一消息如何处理。静态联编具有执行速度快的优点。在 C++ 中的编译时多态性是通过函数重载和运算符重载实现的。

运行时多态性：---动态联编(连接)----系统在运行时动态实现某一动作，即对某一消息在运行过程实现其如何响应。动态联编为系统提供了灵活和高度问题抽象的优点，在 C++ 中的运行时多态性是通过继承和虚函数实现的。

### 虚函数

#### 基类与派生类的赋值相容

* 派生类对象可以赋值给基类对象。
* 派生类对象的地址可以赋值给指向基类对象的指针。
* 派生类对象可以作为基类对象的引用。

赋值相容的问题：不论哪种赋值方式，都只能通过基类对象（或基类对象的指针或引用）访问到派生类对象从基类中继承到的成员， 不能借此访问派生类定义的成员。

#### 虚函数使得可以通过基类对象的指针或引用访问派生类定义的成员

#### Virtual 关键字其实质是告知编译系统，被指定为 virtual 的函数采用动态联编的形式编译

#### 虚函数的虚特征

基类指针指向派生类的对象时，通过该指针访问其虚函数将调用派生类的版本

* 一旦将某个成员函数声明为虚函数后，它在继承体系中就永远为虚函数
* 如果基类定义了虚函数，当通过基类指针或引用调用派生类对象时，将访问到它们实际所指对象中的虚函数版本
* 只有通过基类对象的指针和引用访问派生类对象的虚函数时，才能体现虚函数的特性
* 派生类中的虚函数要保持其虚特征，必须与基类虚函数的函数原型完全相同，否则就是普通的重载函数，与基类的虚函数无关
* 派生类通过从基类继承的成员函数调用虚函数时，将访问到派生类中的版本
* 只有类的非静态成员函数才能被定义为虚函数，类的构造函数和静态成员函数不能定义为虚函数。原因是虚函数在继承层次结构中才能够发生作用，而构造函数、静态成员是不能够被继承的
* 内联函数也不能是虚函数。因为内联函数采用的是静态联编的方式，而虚函数是在程序运行时才与具体函数动态绑定的，采用的是动态联编的方式，即使虚函数在类体内被定义，C++ 编译器也将它视为非内联函数

#### 基类析构函数几乎总是为虚析构函数

假定使用 delete 和一个指向派生类的基类指针来销毁派生类对象，如果基类析构函数不为虚,就如一个普通成员函数，delete 函数调用的就是基类析构函数。在通过基类对象的引用或指针调用派生类对象时，将致使对象析构不彻底

### 纯虚函数和抽象类

**纯虚函数**：仅定义函数原型而不定义其实现的虚函数

```cpp
class X {
  virtual ret_type func_name (param) = 0;
}
```

**抽象类**：包含一个或多个纯虚函数的类

抽象类不能被实例化，但可以定义抽象类的指针和引用

定义一个抽象类的派生类意味着定义所有纯虚函数

C++ 对抽象类的限定：

* 抽象类中含有纯虚函数，由于纯虚函数没有实现代码，所有不能建立抽象类的对象
* 抽象类只能作为其他类的基类，可以通过抽象类对象的指针或引用和访问到它的派生类对象，实现运行时的多态
* 如果派生类只是简单地继承了抽象类的纯虚函数，而没有重新定义基类的纯虚函数，则派生类也是一个抽象类

## 模板

### 函数模板

#### 函数模板的特化

针对模板不能处理的特殊数据类型，编写与模板同名的特殊函数专门处理这些数据类型

形式：

```cpp
template <> 返回类型 函数名<特化的数据类型>(参数表) {
  ...
}
```

* template <> 是模板特化的关键字，<> 中不需要任何内容
* 函数名后的 <> 是需要特化处理的数据类型

#### 说明

* 当程序中同时存在模板和它的特化时，特化将被优先调用
* 在同一个程序中，除了函数模板和它的特化外，还可以有同名的普通函数。其区别在于C++会对普通函数的调用实参进行隐式的类型转换，但不会对模板函数及特化函数的参数进行任何形式的类型转换

#### 调用顺序

当同一程序中具有模板与普通函数时，其匹配顺序如下：

1. 完全匹配的非模板函数
2. 完全匹配的模板函
3. 类型相容的非模板函数

### 类模板

#### 非类型参数

非类型参数是指某种具体的数据类型，在调用模板时只能为其提供用相应类型的常数值。非类型参数是受限制的，通常可以是整型、枚举型、对象或函数的引用，以及对象、函数或类成员的指针，**但不允许用浮点型（或双精度型）、类对象或void作为非类型参数**。

在下面的模板参数表中，T1、T2是类型参数，T3是非类型参数。

```cpp
template<class T1,class T2,int T3>
```

在实例化时，必须为T1、T2提供一种数据类型，为T3指定一个整常数（如10），该模板才能被正确地实例化。

#### 特化

类模板有两种特化方式：一种是特化整个类模板，另一种是特化个别成员函数

特化类模板：

```cpp
template<>  void Array<char *>::Sort(){
    for(int i=0;i<Size-1;i++){
        int p=i;
        for(int j=i+1;j<Size;j++)
            if(strcmp(a[p],a[j])<0)
                p=j;
        char* t=a[p];
        a[p]=a[i];
        a[i]=t;
    }
}
```

特化成员函数：

```c++
template <> 返回类型 类模板名<特化的数据类型>::特化成员函数名(参数表){
  ...   //函数定义体
}
```

## 输入

用cin输入字符串数据时，如果字符串中含有空白就不能完整输入。因为遇到空白字符时，cin就认为字符串结束了

### 用函数get和getline读取数据

用法：`a = cin.get()` 或者 `cin.get(a)`

结束条件：输入字符足够后回车

说明：这个是单字符的输入，用途是输入一个字符，把它的ASCALL码存入到a中

处理方法：与cin不同，cin.get()在缓冲区遇到[enter]，[space]，[tab]不会作为舍弃，而是继续留在缓冲区中

#### get()

##### get()两个参数

`cin.get(arrayname,size)`把字符输入到arrayname中，长度不超过size

##### get()三个参数

用法：cin.get(arrayname,size,s) ?把数据输入到arrayname字符数组中，当到达长度size时结束或者遇到字符s时结束

注释：a必须是字符数组，即char a[]l类型，不可为string类型；size为最大的输入长度；s为控制，遇到s则当前输入结束缓存区里的s将被舍弃

#### 区别

* cin.get(arrayname,size)当遇到[enter]时会结束目前输入，他不会删除缓冲区中的[enter]
* cin.getline(arrayname,size)当遇到[enter]时会结束当前输入，但是会删除缓冲区中的[enter]

### extern "C"

在我们创建 DLL 工程的时候，常会看到在 dll 头文件要导出的函数声明中有 extern "C" 关键字。

只有在编写 C++ 代码的时候才应使用这个修饰符，在编写C代码的时候不用此修饰符。因为 C++ 编译器经常会对函数名和变量名称在编译的时候进行不可察觉的改变(mangle)，而这在函数连接的时候就会导致严重的问题。例如，dll 库是作者使用 C++ 编写的，而测试的程序是由 C 语言编写的，那么在编译的过程中，dll 库中的函数名会被编译器进行改变，但由 C 语言所写的测试程序并不会被改变，那么在连接器试图连接可执行文件的时候，会发现可执行文件引用了一个并不存在的符号而报错。extern "C" 的作用就是告诉编译器，不要对 C++ 代码的函数进行改变。

所以在混合使用 C 语言和 C++ 编程的时候一定要使用`extern "C"`修饰。

## 函数使用

### dlopen

<https://www.cnblogs.com/sleepylulu/p/12029467.html>
